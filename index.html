<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- üö® SCRIPT DE EMERG√äNCIA - DEVE SER O PRIMEIRO A EXECUTAR -->
    <script>
      // üö´ SCRIPT PARA SILENCIAR ERROR BOUNDARY COMPLETAMENTE
      console.log('üîá SILENCIADOR DE ERROR BOUNDARY ATIVADO');
                      console.log('üïê P√ÅGINA ATUALIZADA EM: Mon Jul 14 10:05:45 -03 2025');
        console.log('üöÄ DEPLOY VERSION: ZERO-POLLING-FINAL');

      // Interceptar console.error para silenciar mensagens de Error Boundary
      const originalConsoleError = console.error;
      console.error = function(...args) {
        const message = args.join(' ').toLowerCase();
        
        // Silenciar mensagens relacionadas a Error Boundary
        if (message.includes('error boundary') || 
            message.includes('ipad error boundary') ||
            message.includes('componentdidcatch') ||
            message.includes('getderivedstatefromerror')) {
          
          console.log('üîá Error Boundary message silenciado:', args[0]);
          return;
        }
        
        // Permitir outras mensagens de erro
        originalConsoleError.apply(console, args);
      };

      // Interceptar console.log para silenciar mensagens de Error Boundary
      const originalConsoleLog = console.log;
      console.log = function(...args) {
        const message = args.join(' ').toLowerCase();
        
        // Silenciar mensagens relacionadas a Error Boundary
        if (message.includes('error boundary') || 
            message.includes('ipad error boundary') ||
            message.includes('componentdidcatch') ||
            message.includes('getderivedstatefromerror')) {
          
          return; // Silenciar completamente
        }
        
        // Permitir outras mensagens
        originalConsoleLog.apply(console, args);
      };

      console.log('‚úÖ SILENCIADOR DE ERROR BOUNDARY INSTALADO');
    </script>
    <script>
      // üö® SCRIPT DE EMERG√äNCIA - INTERCEPTAR ERROS DOM + FIREFOX
      // Este script executa IMEDIATAMENTE quando a p√°gina carrega
      // para prevenir erros removeChild que quebram a aplica√ß√£o

      (function() {
        console.log('üö® SCRIPT DE EMERG√äNCIA ATIVADO');
        
        // üîç DETEC√á√ÉO DE NAVEGADOR
        const detectBrowser = () => {
          const userAgent = navigator.userAgent.toLowerCase();
          const isFirefox = userAgent.includes('firefox');
          const isChrome = userAgent.includes('chrome') && !userAgent.includes('edge');
          const isSafari = userAgent.includes('safari') && !userAgent.includes('chrome');
          const isEdge = userAgent.includes('edge');
          
          console.log('üîç EMERG√äNCIA: Navegador detectado:', {
            userAgent,
            isFirefox,
            isChrome,
            isSafari,
            isEdge
          });
          
          return { isFirefox, isChrome, isSafari, isEdge };
        };
        
        const browser = detectBrowser();
        
        // ü¶ä CONFIGURA√á√ïES ESPEC√çFICAS PARA FIREFOX
        if (browser.isFirefox) {
          console.log('ü¶ä FIREFOX DETECTADO - Aplicando corre√ß√µes espec√≠ficas');
          
          // üö´ DESABILITAR COMPLETAMENTE REAL-TIME NO FIREFOX
          window.FIREFOX_DISABLE_REALTIME = true;
          
          // Interceptar erros espec√≠ficos do Firefox
          const originalConsoleError = console.error;
          console.error = function(...args) {
            const message = args.join(' ');
            
            // Filtrar erros NS_ERROR_CONTENT_BLOCKED
            if (message.includes('NS_ERROR_CONTENT_BLOCKED')) {
              console.warn('üö´ FIREFOX: WebSocket bloqueado por CSP - Continuando sem real-time');
              return;
            }
            
            // Outros erros passam normalmente
            originalConsoleError.apply(console, args);
          };
          
          // üîÑ IMPLEMENTAR POLLING SILENCIOSO PARA FIREFOX
          let firefoxPollingInterval;
          
          const startFirefoxPolling = () => {
            console.log('üîÑ FIREFOX: Iniciando polling silencioso a cada 15 segundos');
            
            firefoxPollingInterval = setInterval(() => {
              console.log('üîÑ FIREFOX: Polling silencioso executado');
              
              // Disparar evento personalizado para o React
              const event = new CustomEvent('firefoxPollingUpdate', {
                detail: { timestamp: Date.now() }
              });
              window.dispatchEvent(event);
            }, 15000); // 15 segundos - mais frequente
          };
          
          // üö´ BLOQUEAR COMPLETAMENTE WEBSOCKET NO FIREFOX
          if (window.WebSocket) {
            console.log('üö´ FIREFOX: Bloqueando WebSocket para prevenir loops');
            
            // Substituir WebSocket por uma implementa√ß√£o que falha silenciosamente
            window.WebSocket = function() {
              console.log('üö´ FIREFOX: WebSocket bloqueado - usando polling');
              throw new Error('WebSocket desabilitado no Firefox');
            };
            
            // Bloquear tamb√©m EventSource
            if (window.EventSource) {
              window.EventSource = function() {
                console.log('üö´ FIREFOX: EventSource bloqueado - usando polling');
                throw new Error('EventSource desabilitado no Firefox');
              };
            }
          }
          
          // Iniciar polling ap√≥s 5 segundos (dar tempo para React carregar)
          setTimeout(startFirefoxPolling, 5000);
          
          // Limpar polling quando p√°gina for fechada
          window.addEventListener('beforeunload', () => {
            if (firefoxPollingInterval) {
              clearInterval(firefoxPollingInterval);
            }
          });
        }
        
        // 1. INTERCEPTAR M√âTODOS DOM CR√çTICOS
        const originalRemoveChild = Node.prototype.removeChild;
        const originalAppendChild = Node.prototype.appendChild;
        const originalInsertBefore = Node.prototype.insertBefore;
        
        // Interceptar removeChild para prevenir erros
        Node.prototype.removeChild = function(child) {
          try {
            if (this && child && this.contains && this.contains(child)) {
              return originalRemoveChild.call(this, child);
            } else {
              console.warn('üîß EMERG√äNCIA: Prevenindo removeChild inv√°lido');
              return child;
            }
          } catch (e) {
            console.error('üö® EMERG√äNCIA: Erro removeChild interceptado:', e);
            return child;
          }
        };
        
        // Interceptar appendChild
        Node.prototype.appendChild = function(child) {
          try {
            if (this && child) {
              return originalAppendChild.call(this, child);
            } else {
              console.warn('üîß EMERG√äNCIA: Prevenindo appendChild inv√°lido');
              return child;
            }
          } catch (e) {
            console.error('üö® EMERG√äNCIA: Erro appendChild interceptado:', e);
            return child;
          }
        };
        
        // Interceptar insertBefore
        Node.prototype.insertBefore = function(newNode, referenceNode) {
          try {
            if (this && newNode) {
              return originalInsertBefore.call(this, newNode, referenceNode);
            } else {
              console.warn('üîß EMERG√äNCIA: Prevenindo insertBefore inv√°lido');
              return newNode;
            }
          } catch (e) {
            console.error('üö® EMERG√äNCIA: Erro insertBefore interceptado:', e);
            return newNode;
          }
        };
        
        // 2. FOR√áAR FUNCIONAMENTO DE CLIQUES
        const forceClickFunctionality = () => {
          console.log('üîß EMERG√äNCIA: For√ßando funcionamento de cliques');
          
          // Listener global para capturar TODOS os cliques
          document.addEventListener('click', function(event) {
            console.log('üñ±Ô∏è EMERG√äNCIA: Clique detectado:', event.target.tagName, event.target.className);
            
            // Verificar se √© um bot√£o
            if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
              console.log('üîß EMERG√äNCIA: Bot√£o clicado, verificando funcionalidade');
              
              // Para Firefox, adicionar delay extra
              if (browser.isFirefox) {
                setTimeout(() => {
                  console.log('ü¶ä FIREFOX: Processando clique com delay');
                }, 100);
              }
            }
            
            // Verificar se clique em tarefa
            const taskCard = event.target.closest('[data-task-id]');
            if (taskCard) {
              const taskId = taskCard.getAttribute('data-task-id');
              console.log('üìã EMERG√äNCIA: Clique em tarefa detectado:', taskId);
              
              // Tentar encontrar handler React
              const reactHandler = taskCard.onclick || taskCard._reactInternalFiber;
              if (reactHandler) {
                console.log('‚öõÔ∏è EMERG√äNCIA: Handler React encontrado, executando');
              }
            }
          }, true); // Use capture phase
          
          console.log('‚úÖ EMERG√äNCIA: Listener global instalado');
        };
        
        // 3. INTERCEPTAR ERROS GLOBAIS
        const interceptGlobalErrors = () => {
          window.addEventListener('error', function(event) {
            console.error('üö® EMERG√äNCIA: Erro global capturado:', event.error);
            
            // Para Firefox, tratar erros espec√≠ficos
            if (browser.isFirefox && event.error && event.error.message) {
              if (event.error.message.includes('NS_ERROR_CONTENT_BLOCKED')) {
                console.log('ü¶ä FIREFOX: Erro CSP ignorado');
                event.preventDefault();
                return false;
              }
            }
            
            // Tentar recuperar de erros DOM
            if (event.error && event.error.message && event.error.message.includes('removeChild')) {
              console.log('üîß EMERG√äNCIA: Tentando recuperar de erro removeChild');
              event.preventDefault();
              return false;
            }
          });
          
          // Interceptar promises rejeitadas
          window.addEventListener('unhandledrejection', function(event) {
            console.error('üö® EMERG√äNCIA: Promise rejeitada:', event.reason);
            
            // Para Firefox, tratar rejei√ß√µes espec√≠ficas
            if (browser.isFirefox && event.reason && event.reason.toString().includes('NS_ERROR_CONTENT_BLOCKED')) {
              console.log('ü¶ä FIREFOX: Promise CSP rejeitada - Continuando');
              event.preventDefault();
              return false;
            }
          });
          
          console.log('üîß EMERG√äNCIA: Monitorando erros...');
        };
        
        // 4. EXECUTAR TODAS AS CORRE√á√ïES
        forceClickFunctionality();
        interceptGlobalErrors();
        
        console.log('‚úÖ EMERG√äNCIA: Script de emerg√™ncia instalado com sucesso');
        console.log('üÜï NOVA VERS√ÉO CONFIRMADA: Sun Jul 13 13:54:49 -03 2025');
        
        // 5. MONITORAMENTO CONT√çNUO
        setInterval(() => {
          console.log('üîß EMERG√äNCIA: Monitorando erros...');
        }, 5000);
        
      })();
    </script>
    
    <title>Gerenciador de Tarefas - Rockfeller Navegantes</title>
    <meta name="description" content="Sistema de gerenciamento de tarefas da Rockfeller Navegantes" />
    <meta name="author" content="Rockfeller Navegantes" />

    <meta property="og:title" content="Gerenciador de Tarefas - Rockfeller Navegantes" />
    <meta property="og:description" content="Sistema de gerenciamento de tarefas da Rockfeller Navegantes" />
    <meta property="og:type" content="website" />

    <meta name="twitter:card" content="summary_large_image" />
    
    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <script type="module" crossorigin src="/assets/index-DXJlLBDI.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-BuWmDiF2.css">
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
